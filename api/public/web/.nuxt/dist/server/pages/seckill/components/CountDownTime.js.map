{"version":3,"file":"pages/seckill/components/CountDownTime.js","sources":["webpack:///./pages/seckill/components/CountDownTime.vue?93d8","webpack:///./pages/seckill/components/CountDownTime.vue","webpack:///./pages/seckill/components/CountDownTime.vue?782a","webpack:///./pages/seckill/components/CountDownTime.vue?368f"],"sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._t(\"default\",null,null,{\n    d: _vm.days,\n    h: _vm.hours,\n    m: _vm.mins,\n    s: _vm.seconds,\n    hh: (\"00\" + _vm.hours).slice(-2),\n    mm: (\"00\" + _vm.mins).slice(-2),\n    ss: (\"00\" + _vm.seconds).slice(-2)\n  })],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexport default {\n  name: 'BaseCounter',\n  props: {\n    // 后台返回的时间戳\n    time: {\n      type: Number | String,\n      default: 0\n    },\n    refreshCounter: {\n      type: Number | String,\n      default: 0\n    },\n    // 到期时间\n    end: {\n      type: Number | String,\n      default: 0\n    },\n    // 区分传入的事秒还是毫秒\n    isMiniSecond: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  computed: {\n    // 将获取到的时候进行转化，不管time是毫秒还是秒都转化成秒\n    // 「+」’号。接口返回的一串数字有时候是字符串的形式，有时候是数字的形式（~不能过分相信后端同学，必须自己做好防范~）。所以通过前面加个‘「+」’号 通通转化为数字。\n    duration() {\n      // 处理传入到期时间\n      if (this.end) {\n        let end = String(this.end).length >= 13 ? +this.end : +this.end * 1000\n        end -= Date.now()\n        return end\n      }\n      // 处理入剩余时间\n      return this.isMiniSecond ? Math.round(+this.time / 1000) : Math.round(+this.time)\n    }\n  },\n\n  data() {\n    return {\n      days: '0',\n      hours: '00',\n      mins: '00',\n      seconds: '00',\n      timer: null,\n      curTime: 0 // 当前的时刻，也就是显示在页面上的那个时刻\n    }\n  },\n\n  methods: {\n    // 将duration转化成天数，小时，分钟，秒数的方法\n    durationFormatter(time) {\n      if (!time) return {ss: 0};\n      let t = time;\n      const ss = t % 60;\n      t = (t - ss) / 60;\n      if (t < 1) return {ss};\n      const mm = t % 60\n      t = (t - mm) / 60\n      if (t < 1) return {mm, ss}\n      const hh = t % 24\n      t = (t - hh) / 24\n      if (t < 1) return {hh, mm, ss}\n      const dd = t\n      return {dd, hh, mm, ss}\n    },\n    // 开始执行倒计时的方法\n    countDown() {\n      // 记录下当前时间\n      this.curTime = Date.now()\n      this.getTime(this.duration)\n    },\n    // 倒计时方法\n    getTime(time) {\n      this.timer && clearTimeout(this.timer)\n      if (time < 0){\n        this.$emit('end', true)\n        return\n      }\n      const {dd, hh, mm, ss} = this.durationFormatter(time)\n      this.days = dd || 0\n      this.hours = hh || 0\n      this.mins = mm || 0\n      this.seconds = ss || 0\n      this.timer = setTimeout(() => {\n        /*\n          出于节能的考虑, 部分浏览器在进入后台时(或者失去焦点时), 「会将 setTimeout 等定时任务暂停 待用户回到浏览器时, 才会重新激活定时任务」\n          说是暂停, 其实应该说是延迟, 1s 的任务延迟到 2s, 2s 的延迟到 5s, 实际情况因浏览器而异。\n          原来如此，看来不能每次都只是减1这么简单了（毕竟你把浏览器切到后台之后setTimeout就冷却了，等几秒后切回，然后执行setTimeout，只是减了一秒而已）。\n        */\n        // now 是 setTimeout的回调函数执行的时候的那个时刻。记录当前这个setTimeout的回调函数执行的时间点。\n        const now = Date.now()\n        // 当前这个setTimeout的回调函数执行的时刻距离上 页面上的剩余时间上一次变化的时间段」。其实也就是 「当前这个setTimeout的回调函数执行的时刻距离上 一个setTimeout的回调函数执行的时刻时间段。」\n        // 记录当前这个setTimeout的回调函数执行的时间点距离页面上开始 渲染 剩余时间的 这一段时间。其实此时的diffTime就是=1。\n        const diffTime = Math.floor((now - this.curTime) / 1000)\n        // 在手机端页面回退到后台的时候不会计时，对比时间差，大于1s的重置倒计时\n        const step = diffTime > 1 ? diffTime : 1\n        // 将curTime的值变成当前这个setTimeout的回调函数执行的时间点。\n        this.curTime = now\n        this.getTime(time - step)\n      }, 1000)\n    }\n  },\n\n  mounted() {\n    this.countDown()\n  },\n\n  watch: {\n    duration() {\n      this.countDown()\n    },\n    refreshCounter() {\n      this.countDown()\n    }\n  }\n}\n\n/*\n  // 原创连接https://mp.weixin.qq.com/s/Edk-0pVDZWOkkfZ2mPiCnw\n  总结：\n    1、 为什么要「用setTimeout来模拟setInterval的行为」？\n        可以看看setInterval有什么缺点：\n        定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是合适执行代码，所以真正何时执行代码的时间是不能保证的，而是取决于何时被主线程的事件循环取到并执行。\n        setInterval(fun, n) // 每隔n秒把fun事件推到消息队列中；\n        setInterval有两个缺点：（1）使用setInterval时，某些间隔会被跳过；（2）可能有多个定时器会连续执行；\n        可以这么理解：每个setTimeout产生的任务会直接push到任务队列中，而setInterval在每次把任务push到任务队列前，都要进行一下判断看上次的任务是否仍在队列中；因而采用setTimeout来规避上面的缺点。\n\n    2、为什么要clearTimeout(this.timer)\n        假设现在页面显示的是活动一的时间，这时，执行到setTimeout，在「一秒后」就会把setTimeout里的回调函数放到任务队列中，「注意是一秒后哦」！这时，然而，在这一秒的开头，我们点击了活动二按钮，这时候的活动二的时间就会传入倒计时组件中，然后触发countDown(),也就调用this.getTime(this.duration);，然后执行到setTimeout，也会一秒后把回调函数放到任务队列中。\n        这时，任务队列中就会有两个setTimeout的回调函数了。等待一秒过去，两个回调函数相继执行，我们就会看到页面上的时间一下子背减了2，实际上是很快速地进行了两遍减1的操作。\n        这就是为什么要添加上this.timer && clearTimeout(this.timer);这一句的原因了。就是要把上一个setTimeout清除掉。\n*/\n\n","import mod from \"-!../../../node_modules/babel-loader/lib/index.js??ref--2-0!../../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CountDownTime.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/babel-loader/lib/index.js??ref--2-0!../../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CountDownTime.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./CountDownTime.vue?vue&type=template&id=8477b946&\"\nimport script from \"./CountDownTime.vue?vue&type=script&lang=js&\"\nexport * from \"./CountDownTime.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  \"c92fe214\"\n  \n)\n\nexport default component.exports"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAhBA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAbA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArDA;AACA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAPA;AA7GA;AAuHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}